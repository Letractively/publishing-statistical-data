#summary Notes on MetadataSet and Metadata Structure Definition issue

= SDMX Metadata sets =

== Background ==

SDMX-RDF (or Stats RDF or whatever it gets renamed to) currently supports publication of data sets and associated structure definitions but doesn't yet cover the publication of Reference Metadata. This is a feature of SDMX that we need to support. This page gives outline background and working space in which to develop a proposal.

== SDMX structures ==

SDMX supports publication of _reference metadata_, that is metadata which is not integral with the data but independent from the datasets themselves. Such metadata can be attached at all levels from observations, through time series and datasets, up to data flows and agencies though it is typically used for the dataset and above levels.

In the SDMX Information Model reference metadata is supported by a structure which directly mirrors the DataSet structure, indeed both are specializations of the generic Structure/!StructureUsage pattern which is part of the SDMX Base Layer.

The key concepts are:

   * Metadata Structure Definition (MSD), analogous to Dataset Structure Definition, which defines:
      * where the metadata can be attached
      * the index key that defines that attachment
      * the structure of a Metadata Report which comprises a nestable hierarchical set of metadata attributes

   * !MetadataSet, analogous to a !DataSet, which comprises:
      * an attachment key which connects the !MetadataSet to the allowed attachment level in the corresponding data flow
      * a series of !MetadataAttributeValues which give values for the attributes allow in the MSD
      * an effectiveDate stamp for the metadata

   * !MetadataAttribute, defines an individual attribute that can be included in a metadata report
      * can have an associated concept defining the the semantics of the attribute
      * can have a local type declaration to override the type of the concept
      * can have a local representation declaration to override the representation of the concept
      * can be Coded or Uncoded
      * can be arrange in parent/child hierarchy - this is purely for presentation purposes and does not affect semantics, represented in SMDX-ML as nesting of the !MetadataAttribute declarations
      * have have associated !AttributeProperty annotations  which "allows the !MetadataAttribute to have identifiable text such as a URL"
      * can be declared, within the MSD, as  optional or mandatory

== Proposed changes to SDMX-RDF ==

The proposed approach is to directly mirror the DSD structure to handle MSDs and use the same machinery of component properties for !MetadataAttributes including generating COG-based predefined attributes.

=== Metadata Structure Definition ===

The proposed top level structure is quite simple:

{{{
sdmx:MetadataStructureDefinition a rdfs:Class, owl:Class;
    rdfs:label "Metadata structure definition"@en;
    rdfs:comment "Defines the structure of a MetadataSet"@en;
    rdfs:subClassOf sdmx:Structure;
    .

sdmx:MetadataProperty a rdfs:Class, owl:Class;
    rdfs:label "Metadata property"@en;
    rdfs:comment """Class of properties used to provide metadata values in 
                    metadata reports (sdmx:MetadataSet)"""@en;
    rdfs:subClassOf sdmx:ComponentProperty;
    owl:disjointWith sdmx:MeasureProperty;
    owl:disjointWith sdmx:AttributeProperty;
    owl:disjointWith sdmx:DimensionProperty;
    .

}}}

=== Structure and Structure Usage ===

While not necessary to make this work, the cleanest way to plumb this in seems to be to follow the SDMX architecture in having an abstraction for the notion of a Structure and Structure Usage, make both DSDs and MSDs into specializations of this structure and change the domain/range of `sdmx:structure` to match.

{{{
# --- Structure pattern  --------------------------

sdmx:Structure a rdfs:Class, owl:Class;
    rdfs:label "Structure"@en;
    rdfs:comment """Abstract class for defining the structure (ComponentProperties) 
                   that can be used in some data or metadata set"""@en;
    .

sdmx:DataSet rdfs:subClassOf sdmx:Structure .
sdmx:DataFlow rdfs:subClassOf sdmx:Structure .

sdmx:Structured a rdfs:Class, owl:Class;
    rdfs:label "Structured"@en;
    rdfs:comment """Abstract class for things whose Structure can be defined by an
                  sdmx:Structure declaration, alternative name: StructureUsage"""@en;
    .

sdmx:DataStructureDefinition rdfs:subClassOf sdmx:Structured .
sdmx:MetadataStructureDefinition rdfs:subClassOf sdmx:Structured .

sdmx:structure a rdf:Property, owl:ObjectProperty;
    rdfs:label "structure"@en;
    rdfs:domain sdmx:Structured;
    rdfs:range sdmx:Structure;
    .
    
sdmx:component a rdf:Property, owl:ObjectProperty;
    rdfs:label "component"@en;
    rdfs:domain sdmx:Structure;
    rdfs:range sdmx:ComponentProperty;
    .

sdmx:componentOrder a rdf:Property, owl:ObjectProperty;
    rdfs:label "component order"@en;
    rdfs:domain sdmx:Structure;
    rdfs:range rdf:List;
    rdfs:comment """Optional specification of the order in which dimensions 
            (and optionally other components) should be used. Value is 
            an rdf:List of sdmx:ComponentProperties or sdmx:ComponentSpecifications"""@en;
    .
}}}

=== Nesting ===

One feature of MetadataSets is that they support grouping of properties. For example, a CONTACT metadata field might group together NAME, ADDRESS and PHONE metadata fields. In SDMX this is used purely for presentational purposes.

To support this in SDMX-RDF we need to at least represent the hierarchical structure of metadata fields as part of the MSD. The proposal is to do this as part of the component order machinery. So, as presaged in the modified comment on `sdmx:componentOrder`, the component order list can contain structured entries which indicate nesting. Conveniently this gives us a hook for attaching additional annotations to `sdmx:ComponentProperty` occurrences within the `Structure`. In particular, we also need to be able to indicate whether a metadata field is required or optional.

{{{
# --- Extended structure entries --------------------------

sdmx:ComponentSpecification a rdfs:Class, owl:Class ;
    rdfs:label "Component specification"@en;
    rdfs:comment """Used to define properties of a component (attribute, dimension etc)
           which are specific to its usage in a DSD or MDS. This is used by including 
           instances of sdmx:COmponentSpecification in place of the 
           sdmx:ComponentProperty in an sdmx:componentOrder list"""@en;
    .

sdmx:specifiedComponent a rdf:Property, owl:ObjectProperty;
    rdfs:label "specified component"@en;
    rdfs:comment """Links a component specification to the component property
                    that is being qualified"""@en;
    rdfs:domain sdmx:ComponentSpecification;
    rdfs:range  sdmx:ComponentProperty;
    .

sdmx:commponentRequired a rdf:Property, owl:DatatypeProperty;
    rdfs:label "component required"@en;
    rdfs:comment """Indicates whether a component property is required (true) or 
                    optional (false) in the context of a DSD or MSD"""@en;
    rdfs:domain sdmx:ComponentSpecifition;
    rdfs:range  xsd:boolean;
    .
}}}

Note that by applying the Structure pattern and extending it this way this provides a solution to the core of Issue 30.

Note that, as currently, we would still have `sdmx:component` links for each metadata property in the MSD, including nested properties. This gives a flat easy to query structure as a parallel to the complex nested lists of `sdmx:componentOrder`.

Now we have this generic machinery for annotating component properties then to representing nesting we just need:

{{{
sdmx:childComponents a rdf:Property, owl:ObjectProperty;
    rdfs:label "child components"@en;
    rdfs:comment """Used primarily in sdmx:MetadataStructureDefinitions to indicate a
            grouping of the metadata properties used for presentational purposes.
            The sub components should still be listed as sdmx:components of the 
            structure but in the sdmx:componentList the group is represented by a 
            single sdmx:ComponentSpecification which in turn lists the child 
            components by means of this property"""@en;
    rdfs:domain sdmx:ComponentSpecification;
    rdfs:range  rdf:List;
    .
}}}

Which completes the representation of Metadata Structure Definitions.

=== !MetadataSet ===

Then an actual metadata record would be represented using:

{{{
sdmx:MetadataSet a rdfs:Class, owl:Class;
     rdfs:label "Metadata set"@en;
     rdfs:comment """A report containing metadata via attached MetadataProperties"""@en;
     .

sdmx:metadata a rdf:Property, owl:ObjectProperty;
    rdfs:label "metadata"@en;
    rdfs:comment """Links an entity (from Observation up to DataFlow) to a corresponding metadata record."""@en;
    rdfs:range sdmx:MetadataSet;
    .
}}}

So an instance of `sdmx:MetadataSet` would link to the corresponding MSD via `sdmx:structure` and to metadata values via instances of the specified `sdmx:MetadataProperty` properties.

In the case of nested metadata properties the parent property instance would point to a bNode which in turn would have property values for each of the child properties.

_Alternatively, the !MetadataSet could be entirely flat and the nesting structure in the corresponding MSD consulted when formatting reports. That seems more cumbersome to work with._

=== Flows ===

Finally we need the notion of a !MetadataFlow analogous to a !DataFlow. Again it seems easiest to implement a generic Flow pattern and which the metadata and data cases then instantiate:

{{{

sdmx:MetadataFlow a rdfs:Class, owl:Class;
    rdfs:label "Metadata flow"@en;
    rdfs:comment """A flow of Metadata sets"""@en;
    rdfs:subClassOf sdmx:Structured, sdmx:Flow;
    .

sdmx:metadataFlow a rdf:Property, owl:ObjectProperty;
    rdfs:label "metadata flow"@en;
    rdfs:comment """gives the metadata flow associated with a metadata set"""@en;
    rdfs:domain sdmx:MetadataSet;
    rdfs:range  sdmx:MetaDataFlow;
    .

# --- Flow pattern --------------------------

sdmx:Flow a rdfs:Class, owl:Class;
    rdfs:label "Flow"@en;
    rdfs:comment """Abstract information flow, can be either data or metadata"""@en;
    rdfs:subClassOf sdmx:Structured;
    .

sdmx:DataFlow     rdfs:subClassOf  sdmx:Flow .
sdmx:MetadataFlow rdfs:subClassOf  sdmx:Flow .

sdmx:controllingAgreement a rdf:Property, owl:ObjectProperty;
    rdfs:label "controlling agreement"@en;
    rdfs:domain sdmx:Flow;
    rdfs:range sdmx:ProvisionAgreement;
    .
}}}

=== Metadata properties ===

Many of the COG (Concept Oriented Guidelines) concepts are suited to use in specifying metadata. I propose to generate a set of `sdmx:MetadataProperty` instances, analogous to the existing dimension, attribute and measure instances.

For some common metadata components there are existing RDF vocabularies that consumers would expect to see used. My default proposal is that publishers use COG, or properties corresponding to their own existing schemes, as the default. 

Where they can identify equivalences they be declared via `owl:equivalentProperty` or `rdfs:subPropertyOf` assertions and corresponding inferred assertions should also be made.

Other approaches would be possible.

== Omissions ==

=== Attachment level ===

The current proposal does not include attachment levels. In principle a key or partial key defining the legal attachment restrictions could be added to `sdmx:MetadataStructureDefinition`. However, such information seems to be more useful as a guide for publication. For this initial pass at SDMX-RDF we are aiming at support for consumption and free use of `sdmx:metadata` at any level may be a sufficient starting point.

=== !AttributeProperty annotations ===

SDMX also supports attachment of attribute properties to metadata properties within an MSD. This could easily be supported via the `sdmx:ComponentSpecification` machinery but we would need additional guidance and examples to provide a concrete proposal.

== Worked example ==

_TBD_